\documentclass[../midgard.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\section{Linked list}
\label{h:linked-list}

The linked list is a versatile data structure that can implement sets, queues, key-value maps, lazy data sequences, and other interesting data structures.
It is particularly useful in the extended utxo model of the Cardano blockchain, where many list operations and queries can be validated onchain within minimal local contexts that do not grow with list size.
Meanwhile, offchain queries can access any part of the list via beacon NFTs that pinpoint specific list elements.

We describe two types of linked lists:

\begin{itemize}
    \item The \textbf{key-unordered} linked list is a cheaper/simpler variant that only allows nodes to be appended at the end of the list and does not enforce the order of keys in the list.
      It can be used to implement queues and other sequential data structures.
      However, appending to a list is a sequential operation, which is unsuitable for applications that need multiple independent actors to grow the list simultaneously.
    \item The \textbf{key-ordered} linked list allows nodes to be inserted anywhere in the list, but it applies additional rules to maintain the key-ascending (or descending) order of nodes.
      It can be used to implement sets and key-value maps.
      List insertion is increasingly parallel as the list grows, so the key-ordered linked list is well-suited to applications with multiple independent actors growing the list (see \cref{h:parallel-insertions-in-key-ordered-lists}).
\end{itemize}

\subsection{Terminology}
\label{h:list-terminology}
\begin{itemize}
  \item \textbf{Elements.} Individual units that collectively constitute a linked list.
  \item \textbf{Root.} The first element of a linked list, which serves as the anchor point for the list and is the only element that can exist in an empty list.
  \item \textbf{Nodes.} Elements of a linked list that are not the root.
  \item \textbf{Root Key.} The reserved asset name of the root element's NFT.
  \item \textbf{Node Key.} The bytearray that identifies a node in the list and is stored in the node's NFT asset name after a reserved prefix.
  \item \textbf{Link.} A potential forward pointer from an element to the next node's key in the list.
  \item \textbf{Head.} The first node of a non-empty list, which is the node linked to by the root element.
  \item \textbf{Anchor.} The parent element (either root or node) that points to its next node's key.
\end{itemize}

\subsection{Utxo representation}
\label{h:list-utxo-representation}

Each linked list, whether key-ordered or key-unordered, is represented in the blockchain ledger as a collection of element utxos that hold some ADA, plus NFTs minted by the list's minting policy and are held under the list's spending validator.
The spending validator is aware of the minting policy (either as a parameter or other means), and the minting policy must have a way of ensuring uniqueness of the linked list it initializes.

Each element utxo of a list uniquely corresponds to some \code{ByteArray} key and holds an NFT with an asset name equal to that key's serialization, with a potential prepended label for nodes.
The key-ordered list's state transitions guarantee that all nodes have unique keys, but the key-unordered list's state transitions only assume that keys are unique.

\newcommand{\unorderedListWarning}[0]{
\begin{warningblock}
An application using a key-unordered list MUST only add nodes with unique keys to the list.
Duplicate keys break the linked list data structure.
\end{warningblock}
}
\unorderedListWarning

Every element utxo has a datum of the \code{Element} type, which is parametric on \code{root\_data} and \code{node\_data} types of the data that is to be stored in the list elements:
\begin{equation*}
    \T{Element} (\T{root\_data}, \T{node\_data}) \coloneq \left\{
    \begin{array}{ll}
        \T{link} : & \T{Option}(\T{ByteArray}) \\
        \T{data} : & \T{ElementData} (\T{root\_data}, \T{node\_data})
    \end{array} \right\}
\end{equation*}

The distinction between root elements and nodes is identifiable by the NFTs' asset names.
That is, the NFT of root element has a reserved asset name, while the NFTs of node elements must be unique bytearrays with an optional reserved prefix.\footnote{Prefixing the key when it is serialized to the asset name prevents a collision between the root and a node with an empty key string.
It also allows more flexibility for minting policies that use the linked list library to atomically mint additional tokens associated with the key but namespaced from the node NFTs.}
Additionally, \code{ElementData} is a sum type that provides type-level information about the data stored in root and node elements.
\begin{align*}
  \T{ElementData} \coloneq\;& \T{Root} (\T{root\_data}) \\
                      \mid\;& \T{Node} (\T{node\_data})
\end{align*}

There is no notion of keys in \code{Element} as the data is already present in the NFTs.
If keys are needed to be shared between other contracts of a transaction, they can be included in the redeemer and validated by the minting policy.\footnote{Any interaction with linked list elements requires authenticating their NFTs, which consists of validating the asset names are prefixed with the hardcoded value.
However, in transactions where other contracts are executed along list's minting policy and need access to elements' keys, provision in the mint redeemer can relieve those other contracts from re-extracting the key from asset names.}

The root element is created when a list is initialized and must continue to exist until the list is deinitialized.
This allows an initialized but empty list to be represented by just its root (and no nodes), containing a special data.
The nodes represent the actual keys and data of interest within a non-empty list.

The \code{link} field is a link to the next key that a forward traversal through the list must visit after visiting the current node.
Alternatively, the \code{link} field can be interpreted as the previous key that a backward traversal through the list has visited before the current node.
The last node is the only node with a \code{link} field value of \code{None} because forward traversal through the list must end after this node (backward traversal must start at this node).

\subsection{Linked list library structure}
\label{h:list-library-structure}

The linked list library is designed with a strong focus on alleviating users from the core logic of linked lists and allowing them to focus solely on their application's custom logic.
There are three kinds of functions in the linked list library:
\begin{itemize}
  \item \textbf{For Minting.} Core logic of various state transition operations, namely element additions and removals.
  \item \textbf{For Spending.} Linked list elements must be spendable to either allow state transitions or to allow modifications to the \code{data} field of element datums without changing the list structure.
  \item \textbf{For Inspection.} Validating the presence of particular element utxos in the transaction by other contracts, and validating the contents of their datums.
\end{itemize}

Provided functions for minting each implement a particular linked list operation, and provide users with values that are independent of the linked list's internal logic.
These return values are designed to provide guardrails so that users can cover all edge cases.

There are only two functions for spending: one for updating element data with preservation of list's state, and one for state transitions.

The inspection function validates authenticity of the referenced element and provides various information about the element.

\Cref{h:instantiate-list-in-application} describes how to instantiate a linked list within an application and compose the linked list rules with custom app rules.

\subsection{Common validations}
\label{h:list-common-validations}

\textbf{Element authenticity.} A common requirement for all of the above operations is validating the authenticity of involved element utxos.
The required conditions for each element are:
\begin{itemize}
    \item The element utxos must hold some ADA, and NFTs of the list's minting policy with correct asset names with no other tokens.
    \item The element utxos must have inline datums that parse as \code{Element}.
    \item No reference script must be attached to the utxo.\footnote{This is an opinionated design decision that is not strictly necessary for the linked list itself.
      See \cref{h:list-opinionated-design-decisions}.}
\end{itemize}

Throughout this document we refer to the above conditions with the keyword \textbf{Authentic} for short.

\textbf{Proper continuation.} Another common requirement for all state transition operations is validating the proper reproduction of anchor elements.
This requirment also involves another element that is either being added to the list or removed from it.
Conditions:
\begin{itemize}
  \item Let \code{input\_anchor} be the element that is getting spent.
  \item Let \code{output\_anchor} be the reproduction of \code{input\_anchor} in the transaction outputs.
  \item Let \code{node} be the element that is being added or removed from the list.
  \item \code{input\_anchor}, \code{output\_anchor}, and \code{node} must all be Authentic.
  \item \code{input\_anchor} and \code{output\_anchor} must match on address, asset names of their NFTs, and datum.
  \item Address of \code{node} must have the same payment credential as \code{input\_anchor} and \code{output\_anchor}.\footnote{Note here that \code{node} is not being enforced to share the same staking part as its anchor.
    This is another design decision to balance flexibility and user-friendliness of the API.}
\end{itemize}

Throughout this document we refer to the above conditions with the keyword \textbf{Continue} for short.

\subsection{Minting helpers}
\label{h:list-minting-helpers}

Linked list operations that change the state of the list require minting or burning tokens of the list's minting policy.
These operations can be grouped into four categories:
\begin{itemize}
  \item \textbf{Initialize.} Initialize an empty list by minting the root node NFT.
  \item \textbf{Deinitialize.} Deinitialize an empty list by burning the root node NFT.
  \item \textbf{Addition.} Add a new node to the list by minting a new node NFT and updating the link of an anchor element.
  \item \textbf{Removal.} Remove a non-root node from the list by burning its node NFT and updating the link of its anchor element.
\end{itemize}

The provided functions are as follows:
\begin{description}
    \item[Init.] Mint the root NFT with a given root key, and validate the attached data.
      Conditions:
      \begin{enumerate}
        \item Let \code{nonce\_validated} be a reminder argument for ensuring uniqueueness of the initialized list.
          This condition must be satisfied.
        \item Let \code{produced\_element} be the specified output of the transaction that's meant to represent the list's root.
        \item \code{produced\_element} must be Authentic.
        \item Underlying \code{data} of \code{produced\_element}'s \code{Element} must parse as \code{Root}.
          Let this data be \code{root\_data}.
        \item \code{produced\_element} must not have a link.
        \item Asset name of the NFT in \code{produced\_element} must be the reserved root key.
        \item Let \code{lovelace\_count} be the amount of lovelace in \code{produced\_element}.
        \item Custom validation on \code{lovelace\_count} and \code{root\_data} must pass.
      \end{enumerate}

    \item[Deinit.] Burn the root NFT with a given root key, and validate the attached data.
      Conditions:
      \begin{enumerate}
        \item Let \code{spent\_element} be the specified input of the transaction that's meant to represent the list's root.
        \item \code{spent\_element} must be Authentic.
        \item Underlying \code{data} of \code{spent\_element}'s \code{Element} must parse as \code{Root}.
          Let this data be \code{root\_data}.
        \item \code{spent\_element} must not have a link.
        \item Asset name of the NFT in \code{spent\_element} must be the reserved root key.
        \item Let \code{lovelace\_count} be the amount of lovelace in \code{spent\_element}.
        \item Custom validation on \code{lovelace\_count} and \code{root\_data} must pass.
      \end{enumerate}
    
    \item[Insert.] Add a new node in the list such that its key properly follows either an ascending or descending order.
      Conditions:
      \begin{enumerate}
        \item Let \code{new\_element} be the element that is being added to the list.
        \item Let \code{input\_anchor} be the element that is meant to be parent of \code{new\_element}.
        \item Let \code{output\_anchor} be the reproduction of \code{input\_anchor} in the transaction outputs.
        \item \code{new\_element}, \code{input\_anchor}, and \code{output\_anchor} must Continue.
        \item \code{data} of \code{new\_element} must parse as \code{Node}.
          Let its key be \code{new\_key} and \code{new\_data} be its underlying data.
        \item Transaction must mint a new node NFT with an asset name equal to concatenation of the reserved prefix with \code{new\_key}.
        \item \code{link} of \code{output\_anchor} must point to \code{new\_key}.
        \item Let \code{new\_link} be the \code{link} of \code{new\_element}.
        \item \code{new\_link} must be the same as \code{anchor\_link}.
        \item \code{new\_key} and \code{new\_link} must satisfy the key order of the list (ascending or descending).
        \item Let \code{new\_lovelace} be the amount of Lovelace in \code{new\_element}, and \code{anchor\_lovelace\_change} be the change in the amount of Lovelace in \code{output\_anchor} compared to \code{input\_anchor}.
        \item \code{data} of \code{input\_anchor} must parse as either \code{Root} or \code{Node}.
          \begin{itemize}
            \item If \code{data} of \code{input\_anchor} parses as \code{Root}:
              \begin{enumerate}[resume]
                \item Asset name of the NFT in \code{input\_anchor} must be the reserved root key.
                \item Let \code{root\_data} be the data parsed from \code{input\_anchor}.
                \item Custom validation must pass given:
                  \begin{itemize}
                    \item \code{anchor\_lovelace\_change}
                    \item \code{root\_data}
                    \item \code{new\_lovelace}
                    \item \code{new\_key}
                    \item \code{new\_data}
                    \item \code{new\_link}
                  \end{itemize}
              \end{enumerate}
            \item Otherwise, if \code{data} of \code{input\_anchor} parses as \code{Node}:
              \begin{enumerate}[resume]
                \item Let \code{anchor\_key} be the key of \code{input\_anchor}.
                \item Asset name of the NFT in \code{input\_anchor} must be the reserved prefix concatenated with \code{anchor\_key}.
                \item \code{anchor\_key} and \code{new\_key} must satisfy the key order of the list (ascending or descending).
                \item Let \code{anchor\_data} be the data parsed from \code{input\_anchor}.
                \item Custom validation must pass given:
                  \begin{itemize}
                    \item \code{anchor\_lovelace\_change}
                    \item \code{anchor\_key}
                    \item \code{anchor\_data}
                    \item \code{new\_lovelace}
                    \item \code{new\_key}
                    \item \code{new\_data}
                    \item \code{new\_link}
                  \end{itemize}
              \end{enumerate}
          \end{itemize}
      \end{enumerate}
    \item[Append unordered.] Add a node to the end of the list.
      Conditions are identical to the Insert operation, with only one different stipulation:
      \begin{enumerate}
        \item \code{input\_anchor} must have no \code{link} (i.e., it must be the last element of the list).
      \end{enumerate}
    \item[Prepend unordered.] Add a node in the list as the new head.
      Conditions are identical to the Insert operation, with only one extra stipulation:
      \begin{enumerate}
        \item \code{data} of \code{input\_anchor} must parse as \code{Root}.
      \end{enumerate}
    \item[Remove.] Remove a node from the list.
      Conditions:
      \begin{enumerate}
        \item Let \code{removed\_element} be the element that is being removed from the list.
        \item Let \code{input\_anchor} be the element that is meant to be parent of \code{removed\_element}.
        \item Let \code{output\_anchor} be the reproduction of \code{input\_anchor} in the transaction outputs.
        \item \code{removed\_element}, \code{input\_anchor}, and \code{output\_anchor} must Continue.
        \item \code{data} of \code{removed\_element} must parse as \code{Node}.
          Let its key be \code{removed\_key} and \code{removed\_data} be its underlying data.
        \item Transaction must burn the node NFT with an asset name equal to concatenation of the reserved prefix with \code{removed\_key}.
        \item Let \code{removed\_link} be the \code{link} of \code{removed\_element}.
        \item \code{link} of \code{input\_anchor} must point to \code{removed\_key}.
        \item \code{link} of \code{output\_anchor} must be the same as \code{removed\_link}.
        \item Let \code{removed\_lovelace} be the amount of Lovelace in \code{removed\_element}, and \code{anchor\_lovelace\_change} be the change in the amount of Lovelace in \code{output\_anchor} compared to \code{input\_anchor}.
        \item \code{data} of \code{input\_anchor} must parse as either \code{Root} or \code{Node}.
          \begin{itemize}
            \item If \code{data} of \code{input\_anchor} parses as \code{Root}:
              \begin{enumerate}[resume]
                \item Asset name of the NFT in \code{input\_anchor} must be the reserved root key.
                \item Let \code{root\_data} be the data parsed from \code{input\_anchor}.
                \item Custom validation must pass given:
                  \begin{itemize}
                    \item \code{anchor\_lovelace\_change}
                    \item \code{root\_data}
                    \item \code{removed\_lovelace}
                    \item \code{removed\_key}
                    \item \code{removed\_data}
                    \item \code{removed\_link}
                  \end{itemize}
              \end{enumerate}
            \item Otherwise, if \code{data} of \code{input\_anchor} parses as \code{Node}:
              \begin{enumerate}[resume]
                \item Let \code{anchor\_key} be the key of \code{input\_anchor}.
                \item Asset name of the NFT in \code{input\_anchor} must be the reserved prefix concatenated with \code{anchor\_key}.
                \item Let \code{anchor\_data} be the data parsed from \code{input\_anchor}.
                \item Custom validation must pass given:
                  \begin{itemize}
                    \item \code{anchor\_lovelace\_change}
                    \item \code{anchor\_key}
                    \item \code{anchor\_data}
                    \item \code{removed\_lovelace}
                    \item \code{removed\_key}
                    \item \code{removed\_data}
                    \item \code{removed\_link}
                  \end{itemize}
              \end{enumerate}
          \end{itemize}
      \end{enumerate}
    \item[Fold from root.] Remove the head node of the list and update root's data.
      Conditions are identical to the Remove operation, with some differences:
      \begin{enumerate}
        \item The three elements must Continue, however there is no stipulation for \code{data} of \code{input\_anchor} to be the same as \code{output\_anchor} data.
          This allows the root's data to be modified.
        \item \code{data} of \code{input\_anchor} and \code{output\_anchor} must both parse as \code{Root}.
          Let them be \code{input\_root\_data} and \code{output\_root\_data}, respectively.
        \item Custom validation is provided with both \code{input\_root\_data} and \code{output\_root\_data} in addition.
      \end{enumerate}
\end{description}

\subsection{Spending helpers}
\label{h:list-spending-helpers}

All list state transitions involve spending at least one element utxos, which means the contract address holding the element utxos must have means of allowing them to be spent.
Additionally, there are situations where an application may want to allow spending of element utxos without changing the list structure.

The library provides two functions for spending:
\begin{description}
  \item[State transition.] Allows spending of element utxos for adding or removing an element from the list.
    Conditions:
    \begin{enumerate}
      \item The transaction must mint/burn a non-zero quantity of tokens with policy ID that corresponds to the element NFTs.
    \end{enumerate}
  \item[Update data.] Update the \code{data} field of an element's datum without changing the list structure.
    Conditions:
    \begin{enumerate}
      \item Let \code{input\_element} be the element that is being updated, and \code{output\_element} be its reproduction in the transaction outputs.
      \item \code{input\_element} and \code{output\_element} must both be Authentic.
      \item Addresses, asset names of the NFTs, and \code{link} fields of \code{input\_element} and \code{output\_element} must match.
      \item Let \code{element\_lovelace\_change} be the change in the amount of Lovelace in \code{output\_element} compared to \code{input\_element}.
      \item \code{data} of \code{input\_element} must parse as either \code{Root} or \code{Node}.
        \item If \code{data} of \code{input\_element} parses as \code{Root}:
          \begin{enumerate}[resume]
            \item Let \code{input\_root\_data} be the data parsed from \code{input\_element}.
            \item \code{data} of \code{output\_element} must also parse as \code{Root}.
              Let this data be \code{output\_root\_data}.
            \item Asset name of the NFT in \code{input\_element} must be the reserved root key.
            \item Custom validation must pass given:
              \begin{itemize}
                \item \code{element\_lovelace\_change}
                \item \code{input\_root\_data}
                \item \code{output\_root\_data}
              \end{itemize}
          \end{enumerate}
        \item Otherwise, if \code{data} of \code{input\_element} parses as \code{Node}:
          \begin{enumerate}[resume]
            \item Let \code{input\_node\_data} be the data parsed from \code{input\_element}.
            \item \code{data} of \code{output\_element} must also parse as \code{Node}.
              Let this data be \code{output\_node\_data}.
            \item Let \code{node\_key} be the key of \code{input\_element}.
            \item Asset name of the NFT in \code{input\_element} must be the reserved prefix concatenated with \code{node\_key}.
            \item Custom validation must pass given:
              \begin{itemize}
                \item \code{element\_lovelace\_change}
                \item \code{node\_key}
                \item \code{input\_node\_data}
                \item \code{output\_node\_data}
              \end{itemize}
          \end{enumerate}
    \end{enumerate}
\end{description}

\subsection{Inspection helpers}
\label{h:list-inspection-helpers}

Some contracts may need to refer to elements of other linked list contracts to e.g. prove membership of a given key in those sets.
Relying on the information extracted consists of proving authenticity of the referred utxos.

After validating the element is Authentic, users are provided with following data:
\begin{itemize}
  \item Lovelace count of the element.
  \item A possible node key, since roots have reserved root keys.
  \item Underlying data of the element.
  \item Element's link.
\end{itemize}

\subsection{Reader monad interface}
\label{h:list-reader-monad-interface}

Linked list elements have two constants:
\begin{itemize}
  \item The root key
  \item And the prefix of node keys in node NFT asset names
\end{itemize}

To allow these to be stated only once, most helpers return functions that require provisions of these reserved values.
In addition to the root key and node asset name labels, the reader monad also requires the number of bytes the labels occupy.
While this is a value that should be derived from the labels themselves, its provision prevents extra performance overhead.

\subsection{Opinionated design decisions}
\label{h:list-opinionated-design-decisions}

A few implicit behavior have been implemented by the library in order to keep the API cleaner.
\begin{itemize}
  \item \textbf{Addresses of utxos.} New and removing nodes are allowed to have arbitrary staking parts for their destination addresses, but their payment parts are required to be the same as their anchor elements.
    On the other hand, anchor elements are validated to be reproduced at the same addresses (meaning neither their payment parts nor staking parts can change).
  \item \textbf{Tokens of utxos.} All linked list utxos are validated to carry some ADA (which its quantity is exposed), plus the list NFT and no other tokens.
    Exposing the rest of the assets would not only overwhelm the API, but it would also add extra overhead.
  \item \textbf{Reference scripts.} List utxos are required to have no scripts attached to them.
    This prevents users from bloating utxos and therefore increasing the min required ADA for them, without returning more values for users to handle.
\end{itemize}

\subsection{Instantiate a linked list in an application}
\label{h:instantiate-list-in-application}

Exposed functions are designed to validate anything related to the linked list itself, while providing any data required for custom validations.
However, there are a few considerations to keep in mind when using the library.
\begin{itemize}
  \item \textbf{Limitations for root keys and node prefixes.} Root keys are directly stored in the asset names of root elements, which limits them to be 0 up to and including 32 bytes.
    On the other hand, node key prefixes are stored in node element asset names along with the actual node keys.
    This means users should be aware not to allow the total length to exceed 32 bytes.
  \item \textbf{Datum structures.} All functions assume the linked list instantiation uses an applied version of \code{Element(root\_data, node\_data)}.
\end{itemize}

Midgard uses linked lists throughout its onchain architecture:
\begin{itemize}
    \item \nameref{h:registered-operators} (\cref{h:registered-operators})
    \item \nameref{h:active-operators} (\cref{h:active-operators})
    \item \nameref{h:retired-operators} (\cref{h:retired-operators})
    \item \nameref{h:state-queue} (\cref{h:state-queue})
\end{itemize}


\label{h:parallel-insertions-in-key-ordered-lists}

For keys randomly sampled from an approximately uniform distribution (e.g., cryptographic public keys for wallets), insertion/removal from a key-ordered linked list is parallel to a degree proportional to the list's size, with parallelism increasing as the list grows.

An application may expect highly parallel traffic (e.g., from simultaneous interactions of independent users) before its list grows from its initially small size.
This can be alleviated by using ``separator'' nodes in the list, which boost the list's parallelism by virtually occupying specific keys.
Ideally, separators should be evenly spaced throughout the key space of the list.

\begin{align*}
    \T{MyNodeDatum} &\coloneq \T{NodeDatum} (\T{MyAppDataWithSeps}) \\
    \T{MyAppDataWithSeps} &\coloneq \T{Root}(\T{MyRootData}) \;|\;
        \T{Node}(\T{MyNodeData}) \;|\;
        \T{Separator}
\end{align*}

Suppose the application needs to insert a node at a key occupied by a separator node.
In that case, it will instead modify the node contents (see \cref{h:list-state-integrity-rules}) of the separator node to the intended \code{data} field value of the inserted node.
Otherwise, node insertion works as usual.

The application can insert or remove separators as needed during the lifecycle of the list to regulate its parallelism.

\end{document}

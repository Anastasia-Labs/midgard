\documentclass[../midgard.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\section{Deposit event}
\label{h:deposit-event}

A deposit set is a finite map from deposit IDs to deposit info:
\begin{align*}
    \T{DepositSet} &\coloneq \T{Map(DepositId, DepositInfo)} \\
      &\coloneq \Bigl\{
        (k_i: \T{DepositId}, v_i: \T{DepositInfo}) \mid \forall i \neq j.\; k_i \neq k_j
    \Bigr\}
\end{align*}

A deposit event in a Midgard block acknowledges that a user has created an L1 utxo at the Midgard L1 deposit address, intending to transfer that utxo's tokens to the L2 ledger.
\begin{align*}
    \T{DepositEvent} &\coloneq (\T{DepositId}, \T{DepositInfo}) \\
    \T{DepositId} &\coloneq \T{OutputRef} \\
    \T{DepositInfo} &\coloneq \left\{
        \begin{array}{ll}
            \T{l2\_address} : & \T{Address} \\
            \T{l2\_datum} : & \T{Option(Data)} \\
            \T{midgard\_tokens} : & \T{Pairs(PolicyId, Pairs(AssetName, Int))}
        \end{array} \right\}
\end{align*}

The deposit ID corresponds to one of the inputs spent by the user in the L1 transaction that created the L1 deposit utxo.
This identifier is needed to find the L1 deposit utxo, ensure that deposit events are unique, and detect when an operator has fabricated a deposit event without the corresponding deposit utxo existing in the L1 ledger.

Suppose a deposit event is permitted by Midgard's ledger rules to be included in a block.
In that case, its effect is to add a new L2 utxo to the block's utxo set containing the value from the L1 deposit utxo at the address (\code{l2\_address}) and with the inline datum (\code{l2\_datum}) specified by the user.
The L2 output reference of this new utxo is as follows: 
\begin{equation*}
    \T{l2\_outref(deposit\_id)} \coloneq \left\{
    \begin{array}{ll}
        \T{id} &\coloneq \T{hash(deposit\_id)} \\
        \T{index} &\coloneq 0
    \end{array} \right\}
\end{equation*}
In other words, the L2 ledger treats the new utxo as if it was created by a notional transaction with \code{TxId} equal to the hash of the deposit ID.

If the block containing the deposit event is confirmed, the corresponding L1 deposit utxo may be absorbed into the Midgard reserve.
\Cref{h:deposit} describes the lifecycle of a deposit in further detail, including how the deposit event information is validated.

\subsection{Tokens Management}
\label{h:tokens-management}

Tokens can be catagorized in two classes: Cardano native tokens (or CNTs for short), and Midgard-compatible tokens, which we'll call MCTs.
MCTs are tokens that can be minted on both layers, capable of detecting their layer based on the index of the \code{ScriptContext} instance passed to their underlying UPLC.

They also have implemented logic for cross-layer transfers. Meaning, these tokens are meant to be burnt and re-minted when moving between layers.
This preserves the integrity of token supplies, and prevents added complexity for supply management.
As an example, a deposited token from L1 that ends up burnt on L2, requires additional logic to coordinate this supply discrepency.

However, this is not an issue for CNTs, and therefore they can simply be held within the Midgard reserve, just like ADA.

Whether a token is a CNT or an MCT is decided optimistically, with the \nameref{h:midgard-token-registry} (\cref{h:midgard-token-registry}) contract providing a record for proofs.

If a deposit is not declaring an included token as Midgard-compatible, the active operator can safely ignore that deposit.
To prove such deposits are ignored unjustly, the prover must include the token's registration utxo in the fraud proof transaction.

\end{document}

\documentclass[../midgard.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\section{Off-chain Decoding}
\label{s:phase-two-decoding-off-chain}

This section details the process of decoding UPLC script bytes into executable Terms during phase two validation.

\subsection{Byte Format Specification}

UPLC scripts are serialized using the flat format, which provides a compact binary representation optimized for blockchain storage. The format consists of:

\begin{itemize}
    \item Version number (major.minor.patch) encoded as three natural numbers
    \item Term structure encoded in 4-bit tags (TERM\_TAG\_WIDTH = 4). Specifically:
    \begin{itemize}
        \item 0x0 = Var
        \item 0x1 = Delay
        \item 0x2 = Lambda
        \item 0x3 = Application
        \item 0x4 = Constant
        \item 0x5 = Force
        \item 0x6 = Error
        \item 0x7 = Builtin
        \item 0x8 = Constr
        \item 0x9 = Case
    \end{itemize}
    \item Constants encoded using a 4-bit constructor tag (CONST\_TAG\_WIDTH = 4), with recognized tags:
    \begin{itemize}
      \item 0x0 = Integer
      \item 0x1 = ByteString
      \item 0x2 = String
      \item 0x3 = Unit
      \item 0x4 = Bool
      \item 0x8 = Data
      \item 0x9 = BLS12\_381G1Element (not currently supported in Flat decoding)
      \item 0xA = BLS12\_381G2Element (not currently supported)
      \item 0xB = BLS12\_381MlResult (not currently supported)
      \item For lists and pairs, nested tags are used (e.g.\ [7,5,\dots] or [7,7,6,\dots]).
    \end{itemize}
    \item Built-in functions encoded as 7-bit tags
    \item De Bruijn indices for variable references
    \item Padding bits to ensure byte alignment
\end{itemize}

\subsection{Decoding Process}

The decoding process follows these key steps:

\begin{enumerate}
    \item Read and validate the version number
    \item Parse the term structure by interpreting tag bits:
        \begin{itemize}
            \item 0000 - Var
            \item 0001 - Delay
            \item 0010 - Lambda
            \item 0011 - Application
            \item 0100 - Constant
            \item 0101 - Force
            \item 0110 - Error
            \item 0111 - Built-in functions
            \item 1000 - Constr
            \item 1001 - Case
        \end{itemize}
    \item Decode constants according to their type tags
    \item Resolve built-in function references via their 7-bit tags
    \item Construct the final term tree
\end{enumerate}

\subsection{Term Construction Process}

The decoder maintains state during term construction:

\begin{equation*}
    \text{BytesToTermStep} \coloneq \left\{
    \begin{array}{ll}
        \text{step\_type} : & \text{DecodingStepType} \\
        \text{input\_bytes} : & \text{ScriptBytes} \\
        \text{remaining\_bytes} : & \text{ScriptBytes} \\
        \text{partial\_term} : & \text{Term} \\
        \text{transformation\_proof} : & \text{Hash}
    \end{array} \right\}
\end{equation*}

\subsection{Decoding Step Types}

The \text{DecodingStepType} represents the specific transformation being performed:

\begin{equation*}
    \text{DecodingStepType} \coloneq \left\{
    \begin{array}{ll}
        \text{VersionDecode} : & \text{(major, minor, patch)} \\
        \text{TermTagDecode} : & \text{TagBits} \\
        \text{TypeTagDecode} : & \text{[TypeTag]} \\
        \text{ConstantDecode} : & \text{Type} \times \text{Value} \\
        \text{BuiltinDecode} : & \text{BuiltinTag} \\
        \text{PaddingValidate} : & \text{PaddingBits}
    \end{array} \right\}
\end{equation*}

\subsection{Transformation Proofs}

Each step's \text{transformation\_proof} must demonstrate:

\begin{itemize}
    \item Valid consumption of input bytes according to the format specification
    \item Correct interpretation of decoded values
    \item Proper handling of any padding or alignment requirements
    \item Maintenance of the well-formed term structure
\end{itemize}

For example, a \text{ConstantDecode} proof must show:
\begin{itemize}
    \item The type tag list was properly terminated
    \item The constant value matches its declared type
    \item Any required padding was correctly handled
    \item The remaining bytes are properly aligned
\end{itemize}

\subsection{Validation Chain}

The complete decoding process produces a sequence of \text{BytesToTermStep}s that can be independently verified. This enables:

\begin{itemize}
    \item Detection of malformed script bytes
    \item Identification of specific decoding failures
    \item Construction of fraud proofs for invalid transformations
    \item Verification of the complete decoding process
\end{itemize}

\subsection{Transformation Types}

Different term types require specific decoding transformations:

\begin{itemize}
    \item \textbf{Delay} - Decodes a single sub-term to be delayed
    \item \textbf{Lambda} - Decodes the parameter binder, then the body sub-term
    \item \textbf{Force} - Decodes a single sub-term to be forced
    \item \textbf{Error} - No subfields (represents a failing term)
    \item \textbf{Constr} - Decodes an integer constructor tag, then a list of fields
    \item \textbf{Case} - Decodes one “constr” sub-term (the scrutinee), then a list of branch terms

    \item Constants - Decoded based on a 4-bit constructor tag plus any required type tags:
    \begin{itemize}
      \item Integers, ByteStrings, Strings, Units, and Bools
      \item Lists and Pairs use nested tags for element types
      \item \texttt{Data} for specialized Plutus data
      \item BLS12\_381 types (G1, G2, ML results) are tagged but not supported in current decoding
    \end{itemize}
    \item Applications - Recursively decode function and argument terms
    \item Built-ins - Lookup via 7-bit tag table
    \item Variables - Convert de Bruijn indices to term references
\end{itemize}

\subsection{Validation Requirements}

The decoder must enforce several validation rules:

\begin{itemize}
    \item Version compatibility check
    \item Well-formed term structure
    \item Valid constant values
    \item Recognized built-in functions
    \item Proper scope for de Bruijn indices
    \item Complete byte consumption (no trailing data)
\end{itemize}

\end{document}

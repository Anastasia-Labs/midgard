\documentclass[../midgard.tex]{subfiles}
\graphicspath{{\subfix{../images/}}}
\begin{document}

\section{State Representation}
\label{s:phase-two-state-representation}

This section describes how the state is represented during phase two validation, including the data structures and encoding methods used for UPLC evaluation.

\subsection{Term Representation}

The UPLC Term representation uses progressive hashing to maintain compact state while preserving verifiability:

\begin{equation*}
    \text{Term} \coloneq \left\{
    \begin{array}{ll}
        \text{Variable} : & \text{Name} \\
        \text{Lambda} : & (\text{Name}, \text{Hash}) \\
        \text{Apply} : & (\text{Hash}, \text{Hash}) \\
        \text{Constant} : & \text{Hash} \\
        \text{Force} : & \text{Hash} \\
        \text{Delay} : & \text{Hash} \\
        \text{Builtin} : & \text{BuiltinFunction}
    \end{array} \right\}
\end{equation*}

Each \text{Hash} in the Term representation refers to another Term that has been previously processed and hashed. This creates a directed acyclic graph (DAG) of Term components where larger structures are decomposed into their constituent parts.

For example, a lambda expression like \(\lambda x.\lambda y.[y x]\) would be represented as:
\begin{itemize}
    \item A Lambda node containing \((x, h_1)\)
    \item Where \(h_1\) is the hash of a Lambda node containing \((y, h_2)\)
    \item Where \(h_2\) is the hash of an Apply node containing \((h_3, h_4)\)
    \item Where \(h_3\) is the hash of a Variable node containing \(y\)
    \item Where \(h_4\) is the hash of a Variable node containing \(x\)
\end{itemize}

\subsection{Execution State}

The execution state during UPLC evaluation is represented by the CEK machine state:

\begin{equation*}
    \text{CEKState} \coloneq \left\{
    \begin{array}{ll}
        \text{term\_hash} : & \text{Hash} \\
        \text{env} : & \text{Environment} \\
        \text{kontinuation} : & \text{Kontinuation}
    \end{array} \right\}
\end{equation*}

Each execution step produces a new CEK state and tracks execution units consumed:

\begin{equation*}
    \text{ExecutionStep} \coloneq \left\{
    \begin{array}{ll}
        \text{before\_state} : & \text{CEKState} \\
        \text{after\_state} : & \text{CEKState} \\
        \text{execution\_units} : & \text{ExecutionUnits}
    \end{array} \right\}
\end{equation*}

\subsection{Transformation Steps}

The conversion from flat-encoded script bytes to the final Term follows a sequence of BytesToTermSteps:

\begin{equation*}
    \text{BytesToTermStep} \coloneq \left\{
    \begin{array}{ll}
        \text{remaining\_bytes} : & \text{ScriptBytes} \\
        \text{partial\_term} : & \text{Term}
    \end{array} \right\}
\end{equation*}

Each step represents an atomic transformation in the decoding process, with the \text{transformation\_proof} enabling independent verification of that specific step.

\subsection{Execution Trace}

The complete execution trace combines the bytes-to-term conversion and CEK machine evaluation:

\begin{equation*}
    \text{ExecutionTrace} \coloneq \left\{
    \begin{array}{ll}
        \text{bytes\_to\_term\_steps} : & \mathcal{H}(\text{[BytesToTermStep]}) \\
        \text{initial\_state} : & \text{CEKState} \\
        \text{steps} : & \mathcal{H}(\text{[ExecutionStep]})
    \end{array} \right\}
\end{equation*}

The execution trace is stored in transaction witness sets:

\begin{equation*}
    \text{MidgardTxWits} \coloneq \left\{
    \begin{array}{ll}
        ... \\
        \text{execution\_traces} : & \quad?\;\mathcal{H}(\text{Map(RdmrPtr, ExecutionTrace)})
    \end{array} \right\}
\end{equation*}

This representation allows any step of the trace to be independently verified without requiring access to the complete execution history, enabling efficient fraud proof construction and validation.

\end{document}
